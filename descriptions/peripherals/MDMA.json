{
  "MDMA": [
    {
      "name": "GISR0",
      "description": "global interrupt status register",
      "offset": "0x00",
      "fields": [
        {
          "name": "GIF",
          "description": "Channel x global interrupt flag (x = 15 to 0) This bitfield is set and reset by hardware. It is a logical OR of all channel x interrupt flags (CTCIF, BTIF, BRTIF, TEIF) which are enabled in MDMA_CTCIEx, MDMA_BTIEx, MDMA_BRTIEx, and MDMA_TEIEx. 0: No interrupt generated by channel x1: Interrupt generated by channel x",
          "values": [],
          "mask": "0b1111111111111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111110000000000000000"
        }
      ]
    },
    {
      "name": "CHANNEL",
      "description": "Channel registers for MDMA",
      "type": "CHANNEL",
      "size": 64,
      "offset": "0x40",
      "array": [16]
    }
  ],
  "CHANNEL": [
    {
      "name": "CISR",
      "description": "channel x interrupt status register",
      "offset": "0x00",
      "fields": [
        {
          "name": "CRQA",
          "description": "Channel x request active flag This bit is set by software writing 1 to SWRQx in MDMA_CxCR, in order to request an MDMA transfer, and the channel x is enabled. This bit is also set by hardware when the channel request becomes active, and the channel is enabled. The hardware request memorized until it is served. This bit is cleared by hardware when the cha nnel x request is completed (after the source write phase of the last buffer tr ansfer due for the current request). This bit is also reset by hardware when the channel is disabled (in case of transfer error, or when reaching the end of the c hannel data transfer - repeat block = 0 and linked list pointer null-, or by software programming the channel enable bit to 0 before that).",
          "values": [
            ["0", "The MDMA transfer mdma_strx is inactive for channel x."],
            ["1", "The MDMA transfer mdma_strx is active for channel x"]
          ],
          "mask": "0b10000000000000000"
        },
        {
          "name": "TCIF",
          "description": "Channel x buffer transfe r complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in MDMA_IFCRy.",
          "values": [
            ["0", "No buffer transfer complete event on channel x"],
            ["1", "A buffer transfer complete event occurred on channel xTC is set when a single buffer is transferred. It is activated on each channel transfer request. This can be used as a debug feature (without in terrupt), indicating that (at least) an MDMA buffer transfer has been generated since the last flag reset."]
          ],
          "mask": "0b10000"
        },
        {
          "name": "BTIF",
          "description": "Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in MDMA_IFCRy.",
          "values": [
            ["0", "No block transfer complete event on channel x"],
            ["1", "A block transfer complete event occurred on channel x."]
          ],
          "mask": "0b1000"
        },
        {
          "name": "BRTIF",
          "description": "Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in MDMA_IFCRy.",
          "values": [
            ["0", "No block repeat transfer complete event on channel x"],
            ["1", "A block repeat transfer complete event occurred on channel x"]
          ],
          "mask": "0b100"
        },
        {
          "name": "CTCIF",
          "description": "Channel x channel transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in MDMA_IFCRy.",
          "values": [
            ["0", "No channel transfer complete event on channel x"],
            ["1", "A channel transfer complete event occurred on channel x CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0."]
          ],
          "mask": "0b10"
        },
        {
          "name": "TEIF",
          "description": "Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in MDMA_IFCRy.",
          "values": [
            ["0", "No transfer error on stream x"],
            ["1", "A transfer error occurred on stream x"]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111101111111111100000"
        }
      ]
    },
    {
      "name": "CIFCR",
      "description": "channel x interrupt flag clear register",
      "offset": "0x04",
      "fields": [
        {
          "name": "CLTCIF",
          "description": "Clear buffer transfer complete Interrupt flag for channel x Writing 1 into this bit clears TCIF in MDMA_ISRy.",
          "values": [],
          "mask": "0b10000"
        },
        {
          "name": "CBTIF",
          "description": "Channel x clear block transfer complete interrupt flag Writing 1 into this bit clears BTIF in MDMA_ISRy.",
          "values": [],
          "mask": "0b1000"
        },
        {
          "name": "CBRTIF",
          "description": "Channel x clear block repeat transfer complete interrupt flag Writing 1 into this bit clears BRTIF in MDMA_ISRy.",
          "values": [],
          "mask": "0b100"
        },
        {
          "name": "CCTCIF",
          "description": "Clear channel transfer complete interrupt flag for channel x Writing 1 into this bit clears CTCIF in MDMA_ISRy.",
          "values": [],
          "mask": "0b10"
        },
        {
          "name": "CTEIF",
          "description": "Channel x clear transfer error interrupt flag Writing 1 into this bit clears TEIF in MDMA_ISRy.",
          "values": [],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111111111111111100000"
        }
      ]
    },
    {
      "name": "CESR",
      "description": "channel x error status register",
      "offset": "0x08",
      "fields": [
        {
          "name": "BSE",
          "description": "Block size error This bit is set by hardware, when the block size is not an integer multiple of the data size either for source or destination. TED indica tes whether the problem is on the source or destination. This bit is cleared by software writing 1 to CTEIF in MDMA_IFCRy.",
          "values": [
            ["0", "No block size error"],
            ["1", "Programmed block size is not an integer multiple of the data size. ASE: Address size error This bit is set by hardware, when the programm ed address is not aligned with the data size. TED indicates whether the problem is on the source or destination. It is cleared by software writing 1 to CTEIF in MDMA_IFCRy."],
            ["0", "No address size error"],
            ["1", "Programmed address is not coherent with the data size."]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "TEMD",
          "description": "Transfer error mask data This bit is set by hardware, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to CTEIF in MDMA_IFCRy.",
          "values": [
            ["0", "No mask write access error"],
            ["1", "The last transfer error on the channel was a related to a write of the mask data."]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "TELD",
          "description": "Transfer error link data This bit is set by hardware, in case of a transfer error while reading the block link data structure. It is cleared by softw are writing 1 to CTEIF in MDMA_IFCRy.",
          "values": [
            ["0", "No link data read access error"],
            ["1", "The last transfer error on the channel was a related to a read of the link data structure."]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "TED",
          "description": "Transfer error direction This bit is set and cleared by hardware, in case of an MDMA data transfer error.",
          "values": [
            ["0", "The last transfer error on the channel was a related to a read access."],
            ["1", "The last transfer error on the channel was a related to a write access."]
          ],
          "mask": "0b10000000"
        },
        {
          "name": "TEA",
          "description": "Transfer error address These bits are set and cleared by hardware in case of an MDMA data transfer error. They are used in conjunction with TED. This field indicates the 7 LSB bits of the address which generated a transfer/access error. This field can be used by software to retrieve the failing address, by adding this value (truncated to the buffer transfer leng th size) to the current SAR/DAR value. The SAR/DAR current value does not reflect this last address due to the FIFO management system. The SAR/DAR are only upda ted at the end of a (buffer) transfer (of TLEN+1 bytes). This field is not set in ca se of a link data error.",
          "values": [],
          "mask": "0b1111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111111111000000000000"
        }
      ]
    },
    {
      "name": "CCR",
      "description": "channel x control register",
      "offset": "0x0C",
      "fields": [
        {
          "name": "SWRQ",
          "description": "Software request Writing 1 into this bit sets the CRQA in MDMA_ISRy, activating the request on channel x. Either the whole MDMA_CxCR register or th e 8-/16-bit register at the address offset: 0x4E + 0x40 \u00d7 channel number, can be used for SWRQ activation. In case of software request, acknowledge is not generated (neither hardware signal, nor MDMA_CxMAR write access).",
          "values": [],
          "mask": "0b10000000000000000"
        },
        {
          "name": "WEX",
          "description": "Word endianness exchange This bit is set and cleared by software. This bit is protected and can be written only if EN is 0.",
          "values": [
            ["0", "Little endianness preserved for words"],
            ["1", "Word order exchanged in double wordWhen this bit is set, the word order in the destination double word is reversed: higher address word contains the data read from the lower address of the source. If the destination is not a double word, do not care of this bit value."]
          ],
          "mask": "0b100000000000000"
        },
        {
          "name": "HEX",
          "description": "Half-word endianness exchange This bit is set and cleared by software. This bit is protected and can be written only if EN is 0.",
          "values": [
            ["0", "Little endianness preserved for half words"],
            ["1", "half-word order exchanged in each wordWhen this bit is set, the half-word order in each destination word is reversed: higher address half-word contains the data read from the lower address of the source. If destination length is shorter than word, do not care of this bit value."]
          ],
          "mask": "0b10000000000000"
        },
        {
          "name": "BEX",
          "description": "Byte endianness exchange This bit is set and cleared by software. This bit is protected and can be written only if EN is 0.",
          "values": [
            ["0", "Little endianness preserved for bytes"],
            ["1", "byte order exchanged in each half-wordWhen this bit is set, the byte order in each destination half-word is reversed: higher address word contains the data read from the lower address of the source. If destination is byte, do not care of this bit value."]
          ],
          "mask": "0b1000000000000"
        },
        {
          "name": "PL",
          "description": "Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.",
          "values": [
            ["00", "Low"],
            ["01", "Medium"],
            ["10", "High"],
            ["11", "Very high"]
          ],
          "mask": "0b11000000"
        },
        {
          "name": "TCIE",
          "description": "Buffer transfer complete interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "TC interrupt disabled"],
            ["1", "TC interrupt enabled BTIE : Block transfer interrupt enable This bit is set and cleared by software."],
            ["0", "BT complete interrupt disabled"],
            ["1", "BT complete interrupt enabled"]
          ],
          "mask": "0b100000"
        },
        {
          "name": "BRTIE",
          "description": "Block repeat transfer interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "BT interrupt disabled"],
            ["1", "BT interrupt enabled"]
          ],
          "mask": "0b1000"
        },
        {
          "name": "CTCIE",
          "description": "Channel transfer complete interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "TC interrupt disabled"],
            ["1", "TC interrupt enabled"]
          ],
          "mask": "0b100"
        },
        {
          "name": "TEIE",
          "description": "Transfer error interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "TE interrupt disabled"],
            ["1", "TE interrupt enabled"]
          ],
          "mask": "0b10"
        },
        {
          "name": "EN",
          "description": "Channel enable/flag channel ready when read low This bit is set and cleared by software. When this bit is reset by software, it is recommended to wait for the CTCIF = 1, in order to ensure that any ongoing buffer transfer has been completed, before reprogramming the channel.",
          "values": [
            ["0", "Channel disabled"],
            ["1", "Channel enabledThis bit can be cleared by hardware: \u2013 on a MDMA end of transfer (stream ready to be configured) \u2013 if a transfer error occurs on the AHB/ AXI master buses (bus error/HardFault) \u2013 if another error condition is encounte red (data alignment, block/data size incompatibility) When this bit is reset by software, the ongoing buffer transfer (if any) is completed. All status/configuration registers keep their current values. If the channel is re-enabled without writing these registers, the channel cont inues from the point wh ere it was interrupted. When this bit is read as 0, the software is allowed to program the configuration registers. It is forbidden to write these registers when the EN bit is read as 1 (writes are ignored)."]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111101000111100000000"
        }
      ]
    },
    {
      "name": "CTCR",
      "description": "channel x transfer configuration register",
      "offset": "0x10",
      "fields": [
        {
          "name": "BWM",
          "description": "Bufferable write mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. All MDMA destination accesses are non-cacheable.",
          "values": [
            ["0", "The destination write op eration is non-bufferable."],
            ["1", "The destination write operation is bufferable."]
          ],
          "mask": "0b10000000000000000000000000000000"
        },
        {
          "name": "SWRM",
          "description": "Software request mode This bit is set and cleared by software. If an hardware or software request is currently active, the bit change is delayed until the current transfer is completed. This bit is protected and can be written only if EN is 0.",
          "values": [
            ["0", "Hardware request are taken into account: the transfer is initiated as defined by TRGM value and acknowledged by the MDMA ACKx signal. If the MDMA_CxMAR contains a valid address, the MDMA_CxMDR value is al so written at MDMA_CxMAR address."],
            ["1", "Hardware request are ignored. Transfer is tr iggered by software writing 1 to the SWRQ bit."]
          ],
          "mask": "0b1000000000000000000000000000000"
        },
        {
          "name": "TRGM",
          "description": "Trigger mode These bits are set and cleared by software. If TRGM is 11 for the current block, all values loaded at the end of the current block through the linked-list mechanism must keep the same value (TRGM = 11), and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.",
          "values": [
            ["00", "Each MDMA request (software or hardware) triggers a buffer transfer."],
            ["01", "Each MDMA request (software or hardware) triggers a block transfer."],
            ["10", "Each MDMA request (software or hard ware) triggers a repeated block transfer (if the block repeat is 0, a single block is transferred)."],
            ["11", "Each MDMA request (software or hardware) triggers the transfer of the whole data for the respective channel (for example linked list) until the channel reac h the end and it is disabled."]
          ],
          "mask": "0b110000000000000000000000000000"
        },
        {
          "name": "PAM",
          "description": "Padding/alignment mode These bits are set and cleared by software. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0.",
          "values": [
            ["00", "Right aligned, padded with 0s (default). If source data is la rger than destination size, only LSB part of the source is written to the des tination address. The reminder part is discarded."],
            ["01", "Right aligned, sign extended"],
            ["10", "Left aligned (padded with 0s). if source data is larger than destination size, only MSB part of the source is written to the destinatio n address. The reminder part is discarded."],
            ["11", "Reserved"]
          ],
          "mask": "0b1100000000000000000000000000"
        },
        {
          "name": "PKE",
          "description": "Pack enable This bit is set and cleared by software. This bit is protected and can be written only if EN is 0.",
          "values": [
            ["0", "The source data is written to the destinati on as is. If source size is smaller than destination, it is padded according to the PAM value. If source data size is larger than destination one, it is truncated. The alignmen t is done according to the PAM["],
            ["1", "0] value."],
            ["1", "The source data is packed/unpacked into the destination data size. All data are right aligned, in little-endian mode."]
          ],
          "mask": "0b10000000000000000000000000"
        },
        {
          "name": "TLEN",
          "description": "Buffer transfer length (number of bytes - 1) These bits are set and cleared by software. TLEN + 1 value represents the number of bytes to be transferred in a single transfer. The transfer length must be a multiple of the data size (for both source and destination) When the source/destination sizes are different and padding/truncation is used, TLEN + 1 refers to the source data array size. These bits are protected and can be written only if EN is 0. DBURST value must be programmed in order to ensure that the burst size is lower than the transfer size.",
          "values": [],
          "mask": "0b1111111000000000000000000"
        },
        {
          "name": "DBURST",
          "description": "Destination burst transfer configuration These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. When the destination bus is TCM/AHB (DBU S = 1) and DINCOS = 11 or DINC = 00 or DINCOS \u2260 DSIZE, DBURST must be programmed to 000 (single transfer), else the result is unpredictable. When the destin ation bus is system/AXI bus (DBU S = 0) and DINC = 00, DBURST must be maximum 100 (burst of 16), else the result is unpredictable.",
          "values": [["000", "Single transferN: burst of 2 N beats DBURST value must be programmed as to ens ure that the burst size is lower than the transfer length. If this is not ensured, the result is unpredictable."]],
          "mask": "0b111000000000000000"
        },
        {
          "name": "SBURST",
          "description": "Source burst transfer configuration These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. When the source bus is TCM (SBUS = 1) and SINCOS = 11 or SINC = 00 or SINCOS \u2260SSIZE, SBURST must be programmed to 000 (single transfer), else the result is unpredictable. When the source bus is system/AXI bus ( SBUS = 0) and SINC = 00, SBURST must be maximum 100 (burst of 16), else the result is unpredictable.",
          "values": [["000", "single transferN: burst of 2 N beats SBURST value must be programmed as to ensu re that the burst size is lower than the transfer length. If this is not ens ured, the result is unpredictable."]],
          "mask": "0b111000000000000"
        },
        {
          "name": "DINCOS",
          "description": "Destination increment offset size These bits are set and cleared by software. If DINCOS < DSIZE and DINC \u2260 00, the result is unpredictable. If destination is AHB and DBURST \u2260 000, destination address must be aligned with DINCOS size, else the result is unpredictable. These bits are protected and can be written only if EN = 0.",
          "values": [
            ["00", "byte (8-bit)"],
            ["01", "half-word (16-bit)"],
            ["10", "word (32-bit)"],
            ["11", "Double-Word (64-bit) - This bits have no meaning if bit DINC[1:0] = 00."]
          ],
          "mask": "0b110000000000"
        },
        {
          "name": "SINCOS",
          "description": "Source increment offset size These bits are set and cleared by software. If SINCOS < SSIZE and SINC \u2260 00, the result is unpredictable. If source is TCM/AHB and SBURST \u2260 000, source address must be aligned with SINCOS size, else the result is unpredictable. These bits are protected and can be written only if EN = 0.",
          "values": [
            ["00", "byte (8-bit)"],
            ["01", "half-word (16-bit)"],
            ["10", "word (32-bit)"],
            ["11", "Double-Word (64-bit) - This bits have no meaning if bit SINC[1:0] = 00."]
          ],
          "mask": "0b1100000000"
        },
        {
          "name": "DSIZE",
          "description": "Destination data size These bits are set and cleared by software. If DINCOS < DSIZE and DINC \u2260 00, the result is unpredictable. If a value of 11 is programmed for the TC M access/AHB port, a tr ansfer error occurs (TEIF bit set). DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS = 1). These bits are protected and can be written only if EN = 0.",
          "values": [
            ["00", "Byte (8 bits)"],
            ["01", "Half-word (16 bits)"],
            ["10", "Word (32 bits)"],
            ["11", "Double-word (64 bits)"]
          ],
          "mask": "0b11000000"
        },
        {
          "name": "SSIZE",
          "description": "Source data size These bits are set and cleared by software. If SINCOS < SSIZE and SINC \u2260 00, the result is unpredictable. If a value of 11 is programmed for the TC M access/AHB port, a tr ansfer error occurs (TEIF bit set). SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS = 1). These bits are protected and can be written only if EN is 0.",
          "values": [
            ["00", "Byte (8 bits)"],
            ["01", "Half-word (16 bits)"],
            ["10", "Word (32 bits)"],
            ["11", "Double-word (64 bits)"]
          ],
          "mask": "0b110000"
        },
        {
          "name": "DINC",
          "description": "Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN = 0. When destination is AHB (DBUS = 1), DINC = 00 is forbidden. SINC[1:0] : Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN = 0. When source is AHB (SBUS = 1), SINC = 00 is forbidden.",
          "values": [
            ["00", "Destination address pointer is fixed."],
            ["10", "Destination address pointer is incremented after each data transfer (increment is done according to DINCOS)."],
            ["11", "Destination address pointer is decremented after each data transfer (increment is done according to DINCOS)."],
            ["00", "Source address pointer is fixed."],
            ["10", "Source address pointer is incremented after each data transfer (increment is done according to SINCOS)."],
            ["11", "Source address pointer is decremented after each data transfer (decrement is done according to SINCOS)."]
          ],
          "mask": "0b1100"
        }
      ]
    },
    {
      "name": "CBNDTR",
      "description": "channel x block number of data register",
      "offset": "0x14",
      "fields": [
        {
          "name": "1",
          "description": "031 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 BRC[11",
          "values": [
            ["", "0]BRD UMBRS UMRes.BNDT [16] rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw 1 5 1 4 1 3 1 2 1 1 1 0 9876543210 BNDT[15"],
            ["", "0] rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw"]
          ],
          "mask": "0b0"
        },
        {
          "name": "BRC",
          "description": "Block repeat count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only , indicating the remaining number of blocks, excluding the current one. This register decre ments after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked-list mode, meaning link address valid). These bits are protected and can be written only if EN = 0.",
          "values": [],
          "mask": "0b11111111111100000000000000000000"
        },
        {
          "name": "BRDUM",
          "description": "Block repeat destination address update mode These bits are protected and can be written only if EN = 0.",
          "values": [
            ["0", "At the end of a block transfer, the MDMA_D AR register is updated by adding the DUV to the current DAR value (current destination address)."],
            ["1", "At the end of a block transfer, the MDMA_DAR register is updated by subtracting the DUV from the current DAR value (current destination address)."]
          ],
          "mask": "0b10000000000000000000"
        },
        {
          "name": "BRSUM",
          "description": "Block repeat source address update mode These bits are protected and can be written only if EN = 0.",
          "values": [
            ["0", "At the end of a block transfer, the MDMA_SAR register is updated by adding the SUV to the current SAR value (cur rent source address)."],
            ["1", "At the end of a block transfer, the MDMA_ SAR register is updated by subtracting the SUV from the current SAR value (current source address)."]
          ],
          "mask": "0b1000000000000000000"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b100000000000000000"
        }
      ]
    },
    {
      "name": "CSAR",
      "description": "channel x source address register",
      "offset": "0x18",
      "fields": [
        {
          "name": "6",
          "description": "031 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 SAR[3",
          "values": [["1", "16] rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw 1 5 1 4 1 3 1 2 1 1 1 0 9876543210 SAR[15:0] rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw"]],
          "mask": "0b10"
        },
        {
          "name": "SAR",
          "description": "Source address These bits represent the base addre ss of the peripheral data register from/to which the data is read. They must be aligned with the SSIZE (SAR[1:0] = 00 when SSIZE = 10), but may be unaligned with the SINCOS. When source is TCM/AHB, if ad dress is not aligned with SINCOS, the access must be programmed as single (SBURST = 000). During the channel activity, this register is updat ed, reflecting the current address from which the data is read next. When the block repeat mode is active, when a blo ck transfer is completed, the source address is updated by adding/subtracting the SAU value to t he current value (already updated after the last transfer in the block). When the linked-list mode is active , at the end of a block (repeated or not) transfer, the SAR value is loaded from memory (from address LSA + m). These bits are write-protected and can be written only when bit EN = 0.",
          "values": [],
          "mask": "0b11111111111111111111111111111111"
        }
      ]
    },
    {
      "name": "CDAR",
      "description": "channel x destination address register",
      "offset": "0x1C",
      "fields": [
        {
          "name": "DAR",
          "description": "Destination address Base address of the destination address to which th e data is written. Must be aligned with the DSIZE (for example DAR[0] = 0 when DSIZE=01) , but may be unaligned with the DINCOS. When destination is AHB, if address is not a ligned with DINCOS, access must be programmed as single (DBURST = 000). During the channel activity, this register is updated, reflecting the current address to which the data is written next. When the block repeat mode is active, when a blo ck transfer is completed, the Destination address is updated by adding/subtracting t he DAU value to the current value (after the last transfer in the block). When the linked-list mode is active, at the end of a block (repeated or not) transfer, the DAR value is loaded from memory (from address LSA + m). These bits are write-protected and can be written only when bit EN = 0.",
          "values": [],
          "mask": "0b11111111111111111111111111111111"
        }
      ]
    },
    {
      "name": "CBRUR",
      "description": "channel x block repeat address update register",
      "offset": "0x20",
      "fields": [
        {
          "name": "SUV",
          "description": "Source address update value This value is used to update (by addition or subt raction) the current source address at the end of a block transfer. It must be an integer multiple of SSIZE, in order to keep SAR aligned to SSIZE (SAR[1:0] = 00 when SSIZE = 10). If this value is 0, the next repetition of th e block transfer continues from the next address. When the block repeat mode is not active (BRC=0), this field is ignored. These bits are write-protected and can be written only when bit EN = 0. This field must be programmed to 0 when SINC[1:0] = 00.",
          "values": [],
          "mask": "0b1111111111111111"
        }
      ]
    },
    {
      "name": "CLAR",
      "description": "channel x link address register",
      "offset": "0x24",
      "fields": [
        {
          "name": "1",
          "description": "1631 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 LAR[3",
          "values": [["1", "16] rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw 1 5 1 4 1 3 1 2 1 1 1 0 9876543210 LAR[15:0] rw rw rw rw rw rw rw rw rw rw rw rw rw r r r"]],
          "mask": "0b1000"
        },
        {
          "name": "LAR",
          "description": "Link address register At the end of a (repeated) block transfer, the current channel configuration registers (MDMA_CxTCR, MDMA_CxBNDTR, MDMA_C xSAR, MDMA_CxDAR, MDMA_CxBRUR, MDMA_CxMAR, MDMA_CxMDR and MDMA_CxLAR itse lf) are loaded with the data structure found at this address. If the value of this register is 0, no register update takes place, th e channel is disabled and CTCIF is set, indicating the end of the transfer for this channel. The channel configuration (LAR address) must be in the AXI address space. LAR value must be aligned at a double-word address (LAR[2:0] = 0x0). These bits are write-protected and can be written only when bit EN = 0.",
          "values": [],
          "mask": "0b11111111111111111111111111111111"
        }
      ]
    },
    {
      "name": "CTBR",
      "description": "channel x trigger and bus selection register",
      "offset": "0x28",
      "fields": [
        {
          "name": "DBUS",
          "description": "Destination bus select This bit is protected and ca n be written only if EN is 0.",
          "values": [
            ["0", "The system/AXI bus is used as desti nation (write operation) on channel x."],
            ["1", "The AHB bus/TCM is used as destination (write operation) on channel x."]
          ],
          "mask": "0b100000000000000000"
        },
        {
          "name": "SBUS",
          "description": "Source bus select This bit is protected and ca n be written only if EN is 0.",
          "values": [
            ["0", "The system/AXI bus is used as s ource (read operation) on channel x."],
            ["1", "The AHB bus/TCM is used as source (read operation) on channel x."]
          ],
          "mask": "0b10000000000000000"
        },
        {
          "name": "TSEL",
          "description": "Trigger selection This field selects the hardware trigger (RQ) input for channel x. The ACK is sent on the ACK output having the same index value. When SWRM bit is set (software request selected), this field is ignored. These bits are write-protected and can be written only when bit EN = 0. If multiple channels are triggered by the same ev ent (have the same TSEL value), all of them are triggered in parallel. Only the channel wi th the lowest index acknowledges the request.",
          "values": [],
          "mask": "0b111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111001111111111000000"
        }
      ]
    },
    {
      "name": "CMAR",
      "description": "channel x mask address register",
      "offset": "0x30",
      "fields": [
        {
          "name": "MAR",
          "description": "Mask address A write of the MDR value is also done to this addr ess. This is used to clear the RQ signal generated by the DMA2 by writing to its interrupt clear register. If the value of this register is 0, this function is disabled. These bits are write-protected and can be written only when bit EN = 0.",
          "values": [],
          "mask": "0b11111111111111111111111111111111"
        }
      ]
    },
    {
      "name": "CMDR",
      "description": "channel x mask data register",
      "offset": "0x34",
      "fields": [
        {
          "name": "MDR",
          "description": "Mask data A write of the MDR value is also done to the addr ess defined by the MDMA_MAR register. This is used to clear the RQ signal generated by the DM A2 by writing to its interrupt clear register. These bits are write-protected and can be written only when bit EN = 0.",
          "values": [],
          "mask": "0b11111111111111111111111111111111"
        }
      ]
    }
  ]
}
