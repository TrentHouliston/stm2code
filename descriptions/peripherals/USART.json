{
  "USART": [
    {
      "name": "CR1",
      "description": "control register 1",
      "offset": "0x00",
      "fields": [
        {
          "name": "RXFFIE",
          "description": "RXFIFO full interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when RXFF = 1 in the USART_ISR register"]
          ],
          "mask": "0b10000000000000000000000000000000"
        },
        {
          "name": "TXFEIE",
          "description": "TXFIFO empty interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when TXFE = 1 in the USART_ISR register"]
          ],
          "mask": "0b1000000000000000000000000000000"
        },
        {
          "name": "FIFOEN",
          "description": "FIFO mode enable This bit is set and cleared by software. FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.",
          "values": [
            ["0", "FIFO mode is disabled."],
            ["1", "FIFO mode is enabled.This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000000000000000000000"
        },
        {
          "name": "M1",
          "description": "Word length This bit must be used in conjunction with bit 12 (M 0) to determine the word length. It is set or cleared by software. M[ In 7-bits data length mode , the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.",
          "values": [
            ["1", "0] = \u201800\u2019: 1 start bit, 8 Data bits, n Stop bitM["],
            ["1", "0] = \u201801\u2019: 1 start bit, 9 Data bits, n Stop bitM["],
            ["1", "0] = \u201810\u2019: 1 start bit, 7 Data bits, n Stop bitThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000000000000000000000"
        },
        {
          "name": "EOBIE",
          "description": "End-of-block interrupt enable This bit is set and cleared by software. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when the EOBF flag is set in the USART_ISR register"]
          ],
          "mask": "0b1000000000000000000000000000"
        },
        {
          "name": "RTOIE",
          "description": "Receiver timeout interrupt enable This bit is set and cleared by software. If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when the RTOF bit is set in the USART_ISR register."]
          ],
          "mask": "0b100000000000000000000000000"
        },
        {
          "name": "DEAT",
          "description": "Driver enable assertion time This 5-bit value defines the time between the ac tivation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1 /8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE = 0). If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b11111000000000000000000000"
        },
        {
          "name": "DEDT",
          "description": "Driver enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Drive r Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during th e DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE = 0). If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b111110000000000000000"
        },
        {
          "name": "OVER8",
          "description": "Oversampling mode In LIN, IrDA and Smartcard modes, this bit must be kept cleared.",
          "values": [
            ["0", "Oversampling by 16"],
            ["1", "Oversampling by 8This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000000000"
        },
        {
          "name": "CMIE",
          "description": "Character match interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when the CMF bit is set in the USART_ISR register."]
          ],
          "mask": "0b100000000000000"
        },
        {
          "name": "MME",
          "description": "Mute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as def ined by the WAKE bit. It is se t and cleared by software.",
          "values": [
            ["0", "Receiver in active mode permanently"],
            ["1", "Receiver can switch between Mute mode and active mode."]
          ],
          "mask": "0b10000000000000"
        },
        {
          "name": "M0",
          "description": "Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE = 0).",
          "values": [],
          "mask": "0b1000000000000"
        },
        {
          "name": "WAKE",
          "description": "Receiver wake-up method This bit determines the USART wake-up method from Mute mode. It is set or cleared by software.",
          "values": [
            ["0", "Idle line"],
            ["1", "Address markThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "PCE",
          "description": "Parity control enable This bit selects the hardware parity cont rol (generation and dete ction). When the parity control is enabled, the co mputed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the re ceived data. This bit is set and cleared by software. Once it is set, PC E is active after the current byte (in reception and in transmission).",
          "values": [
            ["0", "Parity control disabled"],
            ["1", "Parity control enabledThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000"
        },
        {
          "name": "PS",
          "description": "Parity selection This bit selects the odd or even parity when th e parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.",
          "values": [
            ["0", "Even parity"],
            ["1", "Odd parityThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "PEIE",
          "description": "PE interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever PE = 1 in the USART_ISR register"]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "TXFNFIE",
          "description": "TXFIFO not-full interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever TXFNF =1 in the USART_ISR register"]
          ],
          "mask": "0b10000000"
        },
        {
          "name": "TCIE",
          "description": "Transmission complete interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever TC = 1 in the USART_ISR register"]
          ],
          "mask": "0b1000000"
        },
        {
          "name": "RXFNEIE",
          "description": "RXFIFO not empty interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever ORE = 1 or RXFNE = 1 in the USART_ISR register"]
          ],
          "mask": "0b100000"
        },
        {
          "name": "IDLEIE",
          "description": "IDLE interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever IDLE = 1 in the USART_ISR register"]
          ],
          "mask": "0b10000"
        },
        {
          "name": "TE",
          "description": "Transmitter enable This bit enables the transmitter. It is set and cleared by software. During transmission, a low pulse on the TE bit (\u20180\u2019 followed by \u20181\u2019) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately writ ten to \u20181\u2019. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.",
          "values": [
            ["0", "Transmitter is disabled"],
            ["1", "Transmitter is enabled"]
          ],
          "mask": "0b1000"
        },
        {
          "name": "RE",
          "description": "Receiver enable This bit enables the receiver. It is set and cleared by software.",
          "values": [
            ["0", "Receiver is disabled"],
            ["1", "Receiver is enabled and begins searching for a start bit"]
          ],
          "mask": "0b100"
        },
        {
          "name": "UESM",
          "description": "USART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode.This bit is set and cleared by software. It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at re set value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "USART not able to wake up the MCU from low-power mode."],
            ["1", "USART able to wake up th e MCU from low-power mode."]
          ],
          "mask": "0b10"
        },
        {
          "name": "UE",
          "description": "USART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART co nfiguration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value.",
          "values": [
            ["0", "USART prescaler and output s disabled, low-power mode"],
            ["1", "USART enabled"]
          ],
          "mask": "0b1"
        }
      ]
    },
    {
      "name": "CR1",
      "description": "control register 1 [alternate]",
      "offset": "0x00",
      "fields": [
        {
          "name": "FIFOEN",
          "description": "FIFO mode enable This bit is set and cleared by software. FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.",
          "values": [
            ["0", "FIFO mode is disabled."],
            ["1", "FIFO mode is enabled.This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000000000000000000000"
        },
        {
          "name": "M1",
          "description": "Word length This bit must be used in conjunction with bit 12 (M 0) to determine the word length. It is set or cleared by software. M[ In 7-bits data length mode , the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported.",
          "values": [
            ["1", "0] = \u201800\u2019: 1 start bit, 8 Data bits, n Stop bitM["],
            ["1", "0] = \u201801\u2019: 1 start bit, 9 Data bits, n Stop bitM["],
            ["1", "0] = \u201810\u2019: 1 start bit, 7 Data bits, n Stop bitThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000000000000000000000"
        },
        {
          "name": "EOBIE",
          "description": "End of Bbock interrupt enable This bit is set and cleared by software. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when the EOBF flag is set in the USART_ISR register"]
          ],
          "mask": "0b1000000000000000000000000000"
        },
        {
          "name": "RTOIE",
          "description": "Receiver timeout interrupt enable This bit is set and cleared by software. If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when the RTOF bit is set in the USART_ISR register."]
          ],
          "mask": "0b100000000000000000000000000"
        },
        {
          "name": "DEAT",
          "description": "Driver enable assertion time This 5-bit value defines the time between the ac tivation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1 /8 or 1/16 bit time, depending on the oversampling rate). This bitfield can only be written when the USART is disabled (UE = 0). If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b11111000000000000000000000"
        },
        {
          "name": "DEDT",
          "description": "Driver enable deassertion time This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Drive r Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate). If the USART_TDR register is written during th e DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed. This bitfield can only be written when the USART is disabled (UE = 0). If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b111110000000000000000"
        },
        {
          "name": "OVER8",
          "description": "Oversampling mode In LIN, IrDA and Smartcard modes, this bit must be kept cleared.",
          "values": [
            ["0", "Oversampling by 16"],
            ["1", "Oversampling by 8This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000000000"
        },
        {
          "name": "CMIE",
          "description": "Character match interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when the CMF bit is set in the USART_ISR register."]
          ],
          "mask": "0b100000000000000"
        },
        {
          "name": "MME",
          "description": "Mute mode enable This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as def ined by the WAKE bit. It is se t and cleared by software.",
          "values": [
            ["0", "Receiver in active mode permanently"],
            ["1", "Receiver can switch between Mute mode and active mode."]
          ],
          "mask": "0b10000000000000"
        },
        {
          "name": "M0",
          "description": "Word length This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description). This bit can only be written when the USART is disabled (UE = 0).",
          "values": [],
          "mask": "0b1000000000000"
        },
        {
          "name": "WAKE",
          "description": "Receiver wake-up method This bit determines the USART wake-up method from Mute mode. It is set or cleared by software.",
          "values": [
            ["0", "Idle line"],
            ["1", "Address markThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "PCE",
          "description": "Parity control enable This bit selects the hardware parity cont rol (generation and dete ction). When the parity control is enabled, the co mputed parity is inserted at the MSB position (9th bit if M = 1; 8th bit if M = 0) and the parity is checked on the re ceived data. This bit is set and cleared by software. Once it is set, PC E is active after the current byte (in reception and in transmission).",
          "values": [
            ["0", "Parity control disabled"],
            ["1", "Parity control enabledThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000"
        },
        {
          "name": "PS",
          "description": "Parity selection This bit selects the odd or even parity when th e parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.",
          "values": [
            ["0", "Even parity"],
            ["1", "Odd parityThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "PEIE",
          "description": "PE interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever PE = 1 in the USART_ISR register"]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "TXEIE",
          "description": "Transmit data register empty This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever TXE =1 in the USART_ISR register"]
          ],
          "mask": "0b10000000"
        },
        {
          "name": "TCIE",
          "description": "Transmission complete interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever TC = 1 in the USART_ISR register"]
          ],
          "mask": "0b1000000"
        },
        {
          "name": "RXNEIE",
          "description": "Receive data register not empty This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever ORE = 1 or RXNE = 1 in the USART_ISR register"]
          ],
          "mask": "0b100000"
        },
        {
          "name": "IDLEIE",
          "description": "IDLE interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever IDLE = 1 in the USART_ISR register"]
          ],
          "mask": "0b10000"
        },
        {
          "name": "TE",
          "description": "Transmitter enable This bit enables the transmitter. It is set and cleared by software. During transmission, a low pulse on the TE bit (\u20180\u2019 followed by \u20181\u2019) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately writ ten to \u20181\u2019. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register. In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts. RE: Receiver enable This bit enables the receiver. It is set and cleared by software.",
          "values": [
            ["0", "Transmitter is disabled"],
            ["1", "Transmitter is enabled"],
            ["0", "Receiver is disabled"],
            ["1", "Receiver is enabled and begins searching for a start bit"]
          ],
          "mask": "0b1000"
        },
        {
          "name": "UESM",
          "description": "USART enable in low-power mode When this bit is cleared, the USART cannot wake up the MCU from low-power mode. When this bit is set, the USART can wake up the MCU from low-power mode.This bit is set and cleared by software. It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode. If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at re set value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "USART not able to wake up the MCU from low-power mode."],
            ["1", "USART able to wake up th e MCU from low-power mode."]
          ],
          "mask": "0b10"
        },
        {
          "name": "UE",
          "description": "USART enable When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART co nfiguration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software. To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit. The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit. In Smartcard mode, (SCEN = 1), the CK pin is always available when CLKEN = 1, regardless of the UE bit value.",
          "values": [
            ["0", "USART prescaler and output s disabled, low-power mode"],
            ["1", "USART enabled"]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11000000000000000000000000000000"
        }
      ]
    },
    {
      "name": "CR2",
      "description": "control register 2",
      "offset": "0x04",
      "fields": [
        {
          "name": "ADD",
          "description": "Address of the USART node These bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode: \u2013 In Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit address mark det ection. The MSB of the charac ter sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3: 0] bits are used. \u2013 In low-power mode: they are used for wake up from low-power mode on character match.When WUS[1:0] is programmed to 0b00 (W UF active on address match), the wake-up from low-power mode is performed when t he received character corresponds to the character programmed through ADD[6:0] or A DD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1. \u2013 In Run mode with Mute mode inactive (for ex ample, end-of-block detection in ModBus protocol): the whole received character (8 bi ts) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set. These bits can only be written when the recepti on is disabled (RE = 0) or when the USART is disabled (UE = 0).",
          "values": [],
          "mask": "0b11111111000000000000000000000000"
        },
        {
          "name": "RTOEN",
          "description": "Receiver timeout enable This bit is set and cleared by software. If the USART does not support the Receiver timeout feature, th is bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Receiver timeout feature disabled."],
            ["1", "Receiver timeout feature enabled. When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the durat ion programmed in the RTOR (receiver timeout register)."]
          ],
          "mask": "0b100000000000000000000000"
        },
        {
          "name": "ABRMOD",
          "description": "Auto baud rate mode These bits are set and cleared by software. If DATAINV = 1 and/or MSBFIRST = 1 the patterns must be the sa me on the line, for example 0xAA for MSBFIRST) If the USART does not support the auto baud rate fe ature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["00", "Measurement of the start bit is used to detect the baud rate."],
            ["01", "Falling edge to falling edge measurement (the re ceived frame must start with a single bit = 1 and Frame = Start10xxxxxx)"],
            ["10", "0x7F frame detection."],
            ["11", "0x55 frame detectionThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE = 0)."]
          ],
          "mask": "0b11000000000000000000000"
        },
        {
          "name": "ABREN",
          "description": "Auto baud rate enable This bit is set and cleared by software. If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "Auto baud rate detection is disabled."],
            ["1", "Auto baud rate detection is enabled."]
          ],
          "mask": "0b100000000000000000000"
        },
        {
          "name": "MSBFIRST",
          "description": "Most significant bit first This bit is set and cleared by software.",
          "values": [
            ["0", "data is transmitted/received with da ta bit 0 first, follo wing the start bit."],
            ["1", "data is transmitted/received with the M SB (bit 7/8) first, following the start bit. This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000000000000"
        },
        {
          "name": "DATAINV",
          "description": "Binary data inversion This bit is set and cleared by software.",
          "values": [
            ["0", "Logical data from the data regi ster are send/received in positive/direct logic. (1 = H, 0 = L)"],
            ["1", "Logical data from the data regi ster are send/received in negative/ inverse logic. (1 = L, 0 = H). The parity bit is also inverted. This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000000000000"
        },
        {
          "name": "TXINV",
          "description": "TX pin active level inversion This bit is set and cleared by software.",
          "values": [
            ["0", "TX pin signal works using the standard logic levels (VDD =1/idle, Gnd = 0/mark)"],
            ["1", "TX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). This enables the use of an external inverter on the TX line. This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000000000"
        },
        {
          "name": "RXINV",
          "description": "RX pin active level inversion This bit is set and cleared by software.",
          "values": [
            ["0", "RX pin signal works using the standard logic levels (V DD =1/idle, Gnd = 0/mark)"],
            ["1", "RX pin signal values are inverted (VDD =0/mark, Gnd = 1/idle). This enables the use of an external inverter on the RX line. This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000000000"
        },
        {
          "name": "SWAP",
          "description": "Swap TX/RX pins This bit is set and cleared by software.",
          "values": [
            ["0", "TX/RX pins are used as defined in standard pinout"],
            ["1", "The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired connection to another UART. This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000000000"
        },
        {
          "name": "LINEN",
          "description": "LIN mode enable This bit is set and cleared by software. If the USART does not support LIN mode, this bi t is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "LIN mode disabled"],
            ["1", "LIN mode enabledThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 regist er, and to detect LIN Sync breaks. This bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000000"
        },
        {
          "name": "STOP",
          "description": "Stop bits These bits are used for programming the stop bits.",
          "values": [
            ["00", "1 stop bit"],
            ["01", "0.5 stop bit."],
            ["10", "2 stop bits"],
            ["11", "1.5 stop bitsThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b11000000000000"
        },
        {
          "name": "CLKEN",
          "description": "Clock enable This bit enables the user to enable the CK pin. If neither synchronous mode nor Smartcard mo de is supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 . In Smartcard mode, in order to provide correct ly the CK clock to the smartcard, the steps below must be respected:UE = 0SCEN = 1GTPR configurationCLKEN= 1UE = 1",
          "values": [
            ["0", "CK pin disabled"],
            ["1", "CK pin enabledThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "CPOL",
          "description": "Clock polarity This bit enables the user to select the polarity of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship If synchronous mode is not sup ported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Steady low value on CK pin outside transmission window"],
            ["1", "Steady high value on CK pin outside transmission windowThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000000000"
        },
        {
          "name": "CPHA",
          "description": "Clock phase This bit is used to select the phase of the clock output on the CK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure 576 and Figure 577 ) If synchronous mode is not sup ported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "The first clock transition is the first data capture edge"],
            ["1", "The second clock transition is the first data capture edge This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "LBCL",
          "description": "Last bit clock pulse This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in synchronous mode. If synchronous mode is not sup ported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "The clock pulse of the last data bit is not output to the CK pin"],
            ["1", "The clock pulse of the last data bit is output to the CK pinCaution: The last bit is the 7th or 8th or 9th data bi t transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register. This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "LBDIE",
          "description": "LIN break detection interrupt enable Break interrupt mask (break detection using break delimiter). If LIN mode is not supported, this bit is re served and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 . The CPOL, CPHA and LBCL bits should no t be written while the transmitter is enabled. LBDL : LINbreak detection length This bit is for selection between 11 bit or 10 bit break detection. If LIN mode is not supported, this bit is re served and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Interrupt is inhibited"],
            ["1", "An interrupt is generated whenever LBDF = 1 in the USART_ISR register"],
            ["0", "10-bit break detection"],
            ["1", "11-bit break detectionThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000"
        },
        {
          "name": "ADDM7",
          "description": "7-bit address detection/4-bit address detection This bit is for selection between 4-bit ad dress detection or 7-bit address detection. In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.",
          "values": [
            ["0", "4-bit address detection"],
            ["1", "7-bit address detection (in 8-bit data mode)This bit can only be written when the USART is disabled (UE = 0)"]
          ],
          "mask": "0b10000"
        },
        {
          "name": "DIS_NSS",
          "description": "NSS pin enable When the DIS_NSS bit is set, the NSS pin input is ignored. When SPI slave mode is not supported, this bi t is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "SPI slave selection depends on NSS input pin."],
            ["1", "SPI slave is always selected and NSS input pin is ignored."]
          ],
          "mask": "0b1000"
        },
        {
          "name": "SLVEN",
          "description": "Synchronous Slave mode enable When the SLVEN bit is set, the synchronous slave mode is enabled. When SPI slave mode is not supported, this bi t is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Slave mode disabled."],
            ["1", "Slave mode enabled."]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b10000110"
        }
      ]
    },
    {
      "name": "CR3",
      "description": "control register 3",
      "offset": "0x08",
      "fields": [
        {
          "name": "TXFTCFG",
          "description": "TXFIFO threshold configuration",
          "values": [
            ["000", "TXFIFO reaches 1/8 of its depth"],
            ["001", "TXFIFO reaches 1/4 of its depth"],
            ["010", "TXFIFO reaches 1/2 of its depth"],
            ["011", "TXFIFO reaches 3/4 of its depth"],
            ["100", "TXFIFO reaches 7/8 of its depth"],
            ["101", "TXFIFO becomes emptyRemaining combinations: Reserved"]
          ],
          "mask": "0b11100000000000000000000000000000"
        },
        {
          "name": "RXFTIE",
          "description": "RXFIFO threshold interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when Receive FIFO reaches the threshold programmed in RXFTCFG."]
          ],
          "mask": "0b10000000000000000000000000000"
        },
        {
          "name": "RXFTCFG",
          "description": "Receive FIFO threshold configuration",
          "values": [
            ["000", "Receive FIFO reaches 1/8 of its depth"],
            ["001", "Receive FIFO reaches 1/4 of its depth"],
            ["010", "Receive FIFO reaches 1/2 of its depth"],
            ["011", "Receive FIFO reaches 3/4 of its depth"],
            ["100", "Receive FIFO reaches 7/8 of its depth"],
            ["101", "Receive FIFO becomes fullRemaining combinations: Reserved"]
          ],
          "mask": "0b1110000000000000000000000000"
        },
        {
          "name": "TCBGTIE",
          "description": "Transmission complete before guard time, interrupt enable This bit is set and cleared by software. If the USART does not support the Smartc ard mode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever TCBGT=1 in the USART_ISR register"]
          ],
          "mask": "0b1000000000000000000000000"
        },
        {
          "name": "TXFTIE",
          "description": "TXFIFO threshold interrupt enable This bit is set and cleared by software.",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated when TXFIFO reaches the threshold programmed in TXFTCFG."]
          ],
          "mask": "0b100000000000000000000000"
        },
        {
          "name": "WUFIE",
          "description": "Wake-up from low-power mode interrupt enable This bit is set and cleared by software. WUFIE must be set before entering in low-power mode. The WUF interrupt is active only in low-power mode.If the USART does not support th e wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "USART interrupt generated whenever WUF = 1 in the USART_ISR register"]
          ],
          "mask": "0b10000000000000000000000"
        },
        {
          "name": "WUS",
          "description": "Wake-up from low-power mode interrupt flag selection This bitfield specifies the event which acti vates the WUF (wake-up from low-power mode flag).",
          "values": [
            ["00", "WUF active on address match (a s defined by ADD[7:0] and ADDM7)"],
            ["01", "Reserved."],
            ["10", "WUF active on start bit detection"],
            ["11", "WUF active on RXNE/RXFNE. This bitfield can only be written when the USART is disabled (UE = 0).If the USART does not support th e wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 ."]
          ],
          "mask": "0b1100000000000000000000"
        },
        {
          "name": "SCARCNT",
          "description": "Smartcard auto-retry count This bitfield specifies the number of retries for transmission and reception in Smartcard mode. In transmission mode, it specifies the number of automatic retransmi ssion retries, before generating a transmission error (FE bit set). In reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RX FNE and PE bits set). This bitfield must be programmed only when the USART is disabled (UE = 0).When the USART is enabled (UE = 1), this bitfield may only be written to 0x0, in order to stop retransmission. If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0x0", "retransmission disabled - No automatic retransmission in transmit mode. 0x1 to"],
            ["0x7", "number of autom atic retransmission attempts (before signaling error)"]
          ],
          "mask": "0b11100000000000000000"
        },
        {
          "name": "DEP",
          "description": "Driver enable polarity selection If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "DE signal is active high."],
            ["1", "DE signal is active low.This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000000000"
        },
        {
          "name": "DEM",
          "description": "Driver enable mode This bit enables the user to activate the exter nal transceiver control, through the DE signal. If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "DE function is disabled."],
            ["1", "DE function is enabled. The DE signal is output on the RTS pin.This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000000"
        },
        {
          "name": "DDRE",
          "description": "DMA Disable on reception error The reception errors are: parity error, framing error or noise error.",
          "values": [
            ["0", "DMA is not disabled in case of reception error. The corresponding error flag is set but RXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not asserted, so the erroneous data is not tran sferred (no DMA request), but next correct received data is transferred (used for Smartcard mode)."],
            ["1", "DMA is disabled following a reception error. The corresponding error flag is set, as well as RXNE. The DMA request is masked until the error flag is cleared. This means that the software must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case FIFO mode is enabled) before clearing the error flag. This bit can only be written when the USART is disabled (UE=0)."]
          ],
          "mask": "0b10000000000000"
        },
        {
          "name": "OVRDIS",
          "description": "Overrun disable This bit is used to disable the receive overrun detection. This control bit enables checking the communication flow w/o reading the data",
          "values": [
            ["0", "Overrun Error Flag, ORE, is set when received data is not read before receiving new data."],
            ["1", "Overrun functionality is disabled. If new data is received while the RXNE flag is still setthe ORE flag is not set and the new received da ta overwrites the previous content of the USART_RDR register. When FIFO mode is enabl ed, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO managem ent is enabled, the RXNE flag is to be used. This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000000000000"
        },
        {
          "name": "ONEBIT",
          "description": "One sample bit method enable This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.",
          "values": [
            ["0", "Three sample bit method"],
            ["1", "One sample bit methodThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "CTSIE",
          "description": "CTS interrupt enable If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Interrupt is inhibited"],
            ["1", "An interrupt is generated wheneve r CTSIF = 1 in the USART_ISR register"]
          ],
          "mask": "0b10000000000"
        },
        {
          "name": "CTSE",
          "description": "CTS enable If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "CTS hardware flow control disabled"],
            ["1", "CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0). If the CTS input is asserted while data is being transmitted, then the transmission is completed before stopping. If data is written into the data register while CTS is asserted, the transmission is postponed until CTS is deasserted. This bit can only be written when the USART is disabled (UE = 0)"]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "RTSE",
          "description": "RTS enable If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "RTS hardware flow control disabled"],
            ["1", "RTS output enabled, data is on ly requested when there is s pace in the receive buffer. The transmission of data is expected to cease af ter the current character has been transmitted. The RTS output is deasserted (pulled to 0) when data can be received. This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "DMAT",
          "description": "DMA enable transmitter This bit is set/reset by software",
          "values": [
            ["1", "DMA mode is enabled for transmission"],
            ["0", "DMA mode is disabled for transmission"]
          ],
          "mask": "0b10000000"
        },
        {
          "name": "DMAR",
          "description": "DMA enable receiver This bit is set/reset by software",
          "values": [
            ["1", "DMA mode is enabled for reception"],
            ["0", "DMA mode is disabled for reception"]
          ],
          "mask": "0b1000000"
        },
        {
          "name": "SCEN",
          "description": "Smartcard mode enable This bit is used for enabling Smartcard mode. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Smartcard Mode disabled"],
            ["1", "Smartcard Mode enabledThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100000"
        },
        {
          "name": "NACK",
          "description": "Smartcard NACK enable If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "NACK transmission in case of parity error is disabled"],
            ["1", "NACK transmission during parity error is enabledThis bitfield can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10000"
        },
        {
          "name": "HDSEL",
          "description": "Half-duplex selection Selection of Single-wire Half-duplex mode",
          "values": [
            ["0", "Half duplex mode is not selected"],
            ["1", "Half duplex mode is selected This bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b1000"
        },
        {
          "name": "IRLP",
          "description": "IrDA low-power This bit is used for selecting between normal and low-power IrDA modes If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "Normal mode"],
            ["1", "Low-power modeThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b100"
        },
        {
          "name": "IREN",
          "description": "IrDA mode enable This bit is set and cleared by software. If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "IrDA disabled"],
            ["1", "IrDA enabledThis bit can only be written when the USART is disabled (UE = 0)."]
          ],
          "mask": "0b10"
        },
        {
          "name": "EIE",
          "description": "Error interrupt enable Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE = 1 or ORE = 1 or NE = 1 or UDR = 1 in the USART_ISR register).",
          "values": [
            ["0", "Interrupt inhibited"],
            ["1", "interrupt generated when FE = 1 or ORE = 1 or NE = 1 or UDR = 1 (in SPI slave mode) in the USART_ISR register."]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b10000000000000000"
        }
      ]
    },
    {
      "name": "BRR",
      "description": "baud rate register",
      "offset": "0x0C",
      "fields": [
        {
          "name": "BRR",
          "description": "USART baud rateBRR[15:4]BRR[15:4] = USARTDIV[15:4]BRR[3:0]When OVER8 = 0, BRR[3:0] = USARTDIV[3:0].When OVER8 = 1:BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.BRR[3] must be kept cleared.",
          "values": [],
          "mask": "0b1111111111111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111110000000000000000"
        }
      ]
    },
    {
      "name": "GTPR",
      "description": "guard time and prescaler register",
      "offset": "0x10",
      "fields": [
        {
          "name": "GT",
          "description": "Guard time value This bitfield is used to program the Guard time value in terms of number of baud clock periods. This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value. This bitfield can only be written when the USART is disabled (UE = 0). If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b1111111100000000"
        },
        {
          "name": "PSC",
          "description": "Prescaler valueIn IrDA low-power and normal IrDA mode:PSC[7:0] = IrDA Normal and Low-Power baud ratePSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is di vided by the value given in the register (8 significant bits):In Smartcard mode:PSC[4:0] = Prescaler value PSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency: 00000: Reserved - do not program this value 00001: Divides the source clock by 1 (IrDA mode) / by 2 (Smarcard mode) 00010: Divides the source clock by 2 (IrDA mode) / by 4 (Smartcard mode)00011: Divides the source clock by 3 (IrDA mode) / by 6 (Smartcard mode)...11111: Divides the source clock by 31 (IrDA mode) / by 62 (Smartcard mode)0010 0000: Divides the source clock by 32 (IrDA mode)...1111 1111: Divides the source clock by 255 (IrDA mode) This bitfield can only be written when the USART is disabled (UE = 0). ",
          "values": [],
          "mask": "0b11111111"
        },
        {
          "name": "7",
          "description": "5] must be kept cleared if Smartcard mode is used. This bitfield is reserved and forced by hardware to \u20180\u2019 when the Smartcard and IrDA modes are not supported. Refer to Section 48.4",
          "values": [["", "USART implementation on page 2020 ."]],
          "mask": "0b0"
        }
      ]
    },
    {
      "name": "RTOR",
      "description": "receiver timeout register",
      "offset": "0x14",
      "fields": [
        {
          "name": "RTO",
          "description": "Receiver timeout value This bitfield gives the Receiver timeout value in terms of number of bits during which there is no activity on the RX line. In standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value. In Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, t he CWT/BWT measurement is done starting from the start bit of the last received character. This value must only be programmed once per received character.",
          "values": [],
          "mask": "0b111111111111111111111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111110000000000000000"
        }
      ]
    },
    {
      "name": "RQR",
      "description": "request register",
      "offset": "0x18",
      "fields": [
        {
          "name": "1",
          "description": "2431 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. 1 5 1 4 1 3 1 2 1 1 1 0 9876543210 Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. TXFRQ RXFRQ MMRQ SBKRQABRR Q wwwww",
          "values": [],
          "mask": "0b1000"
        },
        {
          "name": "TXFRQ",
          "description": "Transmit data flush request When FIFO mode is disabled, writing \u20181\u2019 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bi t is reserved and must be kept at reset value. When FIFO is enabled, TXFRQ bit is set to fl ush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes. In FIFO mode, the TXFNF flag is reset during the flush request unti l TxFIFO is empty in order to ensure that no data ar e written in the data register.",
          "values": [],
          "mask": "0b10000"
        },
        {
          "name": "RXFRQ",
          "description": "Receive data flush request Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE. This enables to discard the received data without reading them, and avoid an overrun condition.",
          "values": [],
          "mask": "0b1000"
        },
        {
          "name": "MMRQ",
          "description": "Mute mode request Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.",
          "values": [],
          "mask": "0b100"
        },
        {
          "name": "SBKRQ",
          "description": "Send break request Writing 1 to this bit sets t he SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available. When the application needs to send th e break character following all previously inserted data, including the ones not yet tr ansmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.",
          "values": [],
          "mask": "0b10"
        },
        {
          "name": "ABRRQ",
          "description": "Auto baud rate request Writing 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame. If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b1"
        }
      ]
    },
    {
      "name": "ISR",
      "description": "interrupt and status register",
      "offset": "0x1C",
      "fields": [
        {
          "name": "TXFT",
          "description": "TXFIFO threshold flag This bit is set by hardware when the TX FIFO reaches the thre shold programmed in TXFTCFG of USART_CR3 register i.e. the TXFI FO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit = 1 (bit 31) in the USART_CR3 register.",
          "values": [
            ["0", "TXFIFO does not reach the programmed threshold."],
            ["1", "TXFIFO reached the programmed threshold."]
          ],
          "mask": "0b1000000000000000000000000000"
        },
        {
          "name": "RXFT",
          "description": "RXFIFO threshold flag This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This mean s that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrup t is generated if the RXFTIE bit = 1 (bit 27) in the USART_CR3 register. When the RXFTCFG threshold is configured to \u2018101\u2019, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overr un error. The overrun error occurs after receiving the 18th data.",
          "values": [
            ["0", "Receive FIFO does not reach the programmed threshold."],
            ["1", "Receive FIFO reached the programmed threshold."]
          ],
          "mask": "0b100000000000000000000000000"
        },
        {
          "name": "TCBGT",
          "description": "Transmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE = 1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. If the USART does not support the Smartc ard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and t he Smartcard mode is enabled, the TCBGT reset value is \u20181\u2019. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)"],
            ["1", "Transmission is complete successfully (bef ore Guard time completion and there is no NACK from the smart card)."]
          ],
          "mask": "0b10000000000000000000000000"
        },
        {
          "name": "RXFF",
          "description": "RXFIFO full This bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register. An interrupt is generated if the RXFFIE bit = 1 in the USART_CR1 register.",
          "values": [
            ["0", "RXFIFO not full."],
            ["1", "RXFIFO Full."]
          ],
          "mask": "0b1000000000000000000000000"
        },
        {
          "name": "TXFE",
          "description": "TXFIFO empty This bit is set by hardware when TXFIFO is em pty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register. An interrupt is generated if the TXFEIE bit = 1 (bit 30) in the USART_CR1 register.",
          "values": [
            ["0", "TXFIFO not empty."],
            ["1", "TXFIFO empty."]
          ],
          "mask": "0b100000000000000000000000"
        },
        {
          "name": "REACK",
          "description": "Receive enable acknowledge flag This bit is set/reset by hardware, when the Re ceive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [],
          "mask": "0b10000000000000000000000"
        },
        {
          "name": "TEACK",
          "description": "Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, in order to respect the TE = 0 minimum period.",
          "values": [],
          "mask": "0b1000000000000000000000"
        },
        {
          "name": "WUF",
          "description": "Wake-up from low-power mode flag This bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writin g a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE = 1 in the USART_CR3 register. When UESM is cleared, WUF flag is also cleared. The WUF interrupt is active only in low-power mode. If the USART does not support the wake-up fr om Stop feature, this bit is reserved and kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [],
          "mask": "0b100000000000000000000"
        },
        {
          "name": "RWU",
          "description": "Receiver wake-up from Mute mode This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake- up/mute sequence is recognized. The Mute mo de control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wake-up on IDLE mode is selected, this bi t can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "Receiver in active mode"],
            ["1", "Receiver in Mute mode"]
          ],
          "mask": "0b10000000000000000000"
        },
        {
          "name": "SBKF",
          "description": "Send break flag This bit indicates that a send break character wa s requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.",
          "values": [
            ["0", "Break character transmitted"],
            ["1", "Break character requested by setting SBKRQ bit in USART_RQR register"]
          ],
          "mask": "0b1000000000000000000"
        },
        {
          "name": "CMF",
          "description": "Character match flag This bit is set by hardware, when a the charac ter defined by ADD[7:0] is received. It is cleared by software, writing 1 to th e CMCF in the USART_ICR register. An interrupt is generated if CMIE = 1in the USART_CR1 register.",
          "values": [
            ["0", "No Character match detected"],
            ["1", "Character Match detected"]
          ],
          "mask": "0b100000000000000000"
        },
        {
          "name": "BUSY",
          "description": "Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit dete cted). It is reset at the end of the reception (successful or not).",
          "values": [
            ["0", "USART is idle (no reception)"],
            ["1", "Reception on going"]
          ],
          "mask": "0b10000000000000000"
        },
        {
          "name": "ABRF",
          "description": "Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RX FNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.",
          "values": [],
          "mask": "0b1000000000000000"
        },
        {
          "name": "ABRE",
          "description": "Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register. If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.",
          "values": [],
          "mask": "0b100000000000000"
        },
        {
          "name": "UDR",
          "description": "SPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. If the USART does not support the SPI slav e mode, this bit is reserved and kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "No underrun error"],
            ["1", "underrun error"]
          ],
          "mask": "0b10000000000000"
        },
        {
          "name": "EOBF",
          "description": "End of block flag This bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when t he number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIE = 1 in the USART_CR1 register.It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. If Smartcard mode is not s upported, this bit is reserved and kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "End of Block not reached"],
            ["1", "End of Block (number of characters) reached"]
          ],
          "mask": "0b1000000000000"
        },
        {
          "name": "RTOF",
          "description": "Receiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE = 1 in the USART_CR2 register.In Smartcard mode, the timeout corre sponds to the CWT or BWT timings. If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds th is value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.",
          "values": [
            ["0", "Timeout value not reached"],
            ["1", "Timeout value reached without any data reception"]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "CTS",
          "description": "CTS flag This bit is set/reset by hardware . It is an inverted copy of th e status of the CTS input pin. If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.",
          "values": [
            ["0", "CTS line set"],
            ["1", "CTS line reset"]
          ],
          "mask": "0b10000000000"
        },
        {
          "name": "CTSIF",
          "description": "CTS interrupt flag This bit is set by hardware when the CTS input toggl es, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE = 1 in the USART_CR3 register. If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.",
          "values": [
            ["0", "No change occurred on the CTS status line"],
            ["1", "A change occurred on the CTS status line"]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "LBDF",
          "description": "LIN break detection flag This bit is set by hardware when the LIN break is detected. It is cl eared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "LIN Break not detected"],
            ["1", "LIN break detected"]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "TXFNF",
          "description": "TXFIFO not full TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the U SART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR. An interrupt is generated if the TXFNFI E bit =1 in the USART_CR1 register. The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TX FE are set at the same time). This bit is used during single buffer transmission.",
          "values": [
            ["0", "Transmit FIFO is full"],
            ["1", "Transmit FIFO is not full"]
          ],
          "mask": "0b10000000"
        },
        {
          "name": "TC",
          "description": "Transmission complete This bit indicates that the last data writt en in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set. An interrupt is generated if TCIE = 1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. If TE bit is reset and no transmission is on going, the TC bit is immediately set.",
          "values": [
            ["0", "Transmission is not complete"],
            ["1", "Transmission is complete"]
          ],
          "mask": "0b1000000"
        },
        {
          "name": "RXFNE",
          "description": "RXFIFO not empty RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO. RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXFNEIE = 1 in the USART_CR1 register.",
          "values": [
            ["0", "Data is not received"],
            ["1", "Received data is ready to be read."]
          ],
          "mask": "0b100000"
        },
        {
          "name": "IDLE",
          "description": "Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cl eared by software, writing 1 to the IDLECF in the USART_ICR register. The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MME = 1), IDLE is set if the USART is not mute (RWU = 0), whatever the Mute mode selected by the WAKE bit. If RWU = 1, IDLE is not set.",
          "values": [
            ["0", "No Idle line is detected"],
            ["1", "Idle line is detected"]
          ],
          "mask": "0b10000"
        },
        {
          "name": "ORE",
          "description": "Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR regi ster while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXFNEIE = 1 in the USART_CR1 register, or EIE = 1 in the USART_CR3 register. When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no over run detection) when the bit OVRDIS is set in the USART_CR3 register. NE: Noise detection flag This bit is set by hardware when noise is det ected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interru pt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag c an be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section 48.5.8: Tolerance of the USART receiver to clock deviation on page 2037 ). This error is associated with the character in the USART_RDR.",
          "values": [
            ["0", "No overrun error"],
            ["1", "Overrun error is detected"],
            ["0", "No noise is detected"],
            ["1", "Noise is detected"]
          ],
          "mask": "0b1000"
        },
        {
          "name": "FE",
          "description": "Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writi ng 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, th is bit is set when the maximum number of transmit attempts is reached without su ccess (the card NACKs the data frame). An interrupt is generated if EIE = 1 in the USART_CR3 register. This error is associated with the character in the USART_RDR.",
          "values": [
            ["0", "No Framing error is detected"],
            ["1", "Framing error or break character is detected"]
          ],
          "mask": "0b10"
        },
        {
          "name": "PE",
          "description": "Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register. This error is associated with the character in the USART_RDR.",
          "values": [
            ["0", "No parity error"],
            ["1", "Parity error"]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b111101111111111111111111111100000"
        }
      ]
    },
    {
      "name": "ISR",
      "description": "interrupt and status register [alternate]",
      "offset": "0x1C",
      "fields": [
        {
          "name": "TCBGT",
          "description": "Transmission complete before guard time flag This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register. It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE = 1 in the USART_CR3 register. This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register. If the USART does not support the Smartc ard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and t he Smartcard mode is enabled, the TCBGT reset value is \u20181\u2019. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is received from the card)"],
            ["1", "Transmission is complete successfully (bef ore Guard time completion and there is no NACK from the smart card)."]
          ],
          "mask": "0b10000000000000000000000000"
        },
        {
          "name": "REACK",
          "description": "Receive enable acknowledge flag This bit is set/reset by hardware, when the Re ceive Enable value is taken into account by the USART. It can be used to verify that the USART is ready for reception before entering low-power mode. If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [],
          "mask": "0b10000000000000000000000"
        },
        {
          "name": "TEACK",
          "description": "Transmit enable acknowledge flag This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART. It can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, in order to respect the TE = 0 minimum period.",
          "values": [],
          "mask": "0b1000000000000000000000"
        },
        {
          "name": "WUF",
          "description": "Wake-up from low-power mode flag This bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writin g a 1 to the WUCF in the USART_ICR register. An interrupt is generated if WUFIE = 1 in the USART_CR3 register. When UESM is cleared, WUF flag is also cleared. The WUF interrupt is active only in low-power mode. If the USART does not support the wake-up fr om Stop feature, this bit is reserved and kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [],
          "mask": "0b100000000000000000000"
        },
        {
          "name": "RWU",
          "description": "Receiver wake-up from Mute modeThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake- up/mute sequence is recognized. The Mute mo de control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register. When wake-up on IDLE mode is selected, this bi t can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register. If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [
            ["0", "Receiver in active mode"],
            ["1", "Receiver in Mute mode"]
          ],
          "mask": "0b10000000000000000000"
        },
        {
          "name": "SBKF",
          "description": "Send break flag This bit indicates that a send break character wa s requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.",
          "values": [
            ["0", "Break character transmitted"],
            ["1", "Break character requested by setting SBKRQ bit in USART_RQR register"]
          ],
          "mask": "0b1000000000000000000"
        },
        {
          "name": "CMF",
          "description": "Character match flag This bit is set by hardware, when a the charac ter defined by ADD[7:0] is received. It is cleared by software, writing 1 to th e CMCF in the USART_ICR register. An interrupt is generated if CMIE = 1in the USART_CR1 register.",
          "values": [
            ["0", "No Character match detected"],
            ["1", "Character Match detected"]
          ],
          "mask": "0b100000000000000000"
        },
        {
          "name": "BUSY",
          "description": "Busy flag This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit dete cted). It is reset at the end of the reception (successful or not).",
          "values": [
            ["0", "USART is idle (no reception)"],
            ["1", "Reception on going"]
          ],
          "mask": "0b10000000000000000"
        },
        {
          "name": "ABRF",
          "description": "Auto baud rate flag This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or wh en the auto baud rate operation was completed without success (ABRE = 1) (ABRE, RXNE and FE are also set in this case) It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register. If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.",
          "values": [],
          "mask": "0b1000000000000000"
        },
        {
          "name": "ABRE",
          "description": "Auto baud rate error This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed) It is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register. If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.",
          "values": [],
          "mask": "0b100000000000000"
        },
        {
          "name": "UDR",
          "description": "SPI slave underrun error flag In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register. If the USART does not support the SPI slav e mode, this bit is reserved and kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "No underrun error"],
            ["1", "underrun error"]
          ],
          "mask": "0b10000000000000"
        },
        {
          "name": "EOBF",
          "description": "End of block flag This bit is set by hardware when a complete block has been received (for example T = 1 Smartcard mode). The detection is done when t he number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4. An interrupt is generated if the EOBIE = 1 in the USART_CR1 register.It is cleared by software, writing 1 to the EOBCF in the USART_ICR register. If Smartcard mode is not s upported, this bit is reserved and kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "End of Block not reached"],
            ["1", "End of Block (number of characters) reached"]
          ],
          "mask": "0b1000000000000"
        },
        {
          "name": "RTOF",
          "description": "Receiver timeout This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register. An interrupt is generated if RTOIE = 1 in the USART_CR2 register.In Smartcard mode, the timeout corre sponds to the CWT or BWT timings. If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds th is value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set. The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set. If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.",
          "values": [
            ["0", "Timeout value not reached"],
            ["1", "Timeout value reached without any data reception"]
          ],
          "mask": "0b100000000000"
        },
        {
          "name": "CTS",
          "description": "CTS flag This bit is set/reset by hardware . It is an inverted copy of th e status of the CTS input pin. If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.",
          "values": [
            ["0", "CTS line set"],
            ["1", "CTS line reset"]
          ],
          "mask": "0b10000000000"
        },
        {
          "name": "CTSIF",
          "description": "CTS interrupt flag This bit is set by hardware when the CTS input toggl es, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register. An interrupt is generated if CTSIE = 1 in the USART_CR3 register. If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.",
          "values": [
            ["0", "No change occurred on the CTS status line"],
            ["1", "A change occurred on the CTS status line"]
          ],
          "mask": "0b1000000000"
        },
        {
          "name": "LBDF",
          "description": "LIN break detection flag This bit is set by hardware when the LIN break is detected. It is cl eared by software, by writing 1 to the LBDCF in the USART_ICR. An interrupt is generated if LBDIE = 1 in the USART_CR2 register. If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [
            ["0", "LIN Break not detected"],
            ["1", "LIN break detected"]
          ],
          "mask": "0b100000000"
        },
        {
          "name": "TXE",
          "description": "Transmit data register empty TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writ ing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T = 0 mode, in case of transmission failure). An interrupt is generated if the TXEIE bit = 1 in the USART_CR1 register.",
          "values": [
            ["0", "Data register full"],
            ["1", "Data register not full"]
          ],
          "mask": "0b10000000"
        },
        {
          "name": "TC",
          "description": "Transmission complete This bit indicates that the last data writt en in the USART_TDR has been transmitted out of the shift register. It is set by hardware when the transmission of a frame containing data is complete and when TXE is set. An interrupt is generated if TCIE = 1 in the USART_CR1 register. TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register. If TE bit is reset and no transmission is on going, the TC bit is set immediately.",
          "values": [
            ["0", "Transmission is not complete"],
            ["1", "Transmission is complete"]
          ],
          "mask": "0b1000000"
        },
        {
          "name": "RXNE",
          "description": "Read data register not empty RXNE bit is set by hardware when the conten t of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register. An interrupt is generated if RXNEIE = 1 in the USART_CR1 register.",
          "values": [
            ["0", "Data is not received"],
            ["1", "Received data is ready to be read."]
          ],
          "mask": "0b100000"
        },
        {
          "name": "IDLE",
          "description": "Idle line detected This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE = 1 in the USART_CR1 register. It is cl eared by software, writing 1 to the IDLECF in the USART_ICR register. The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs). If Mute mode is enabled (MME = 1), IDLE is set if the USART is not mute (RWU = 0), whatever the Mute mode selected by the WAKE bit. If RWU = 1, IDLE is not set.",
          "values": [
            ["0", "No Idle line is detected"],
            ["1", "Idle line is detected"]
          ],
          "mask": "0b10000"
        },
        {
          "name": "ORE",
          "description": "Overrun error This bit is set by hardware when the data currently being received in the shift register is ready to be transferred into the USART_RDR regi ster while RXNE = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register. An interrupt is generated if RXNEIE = 1 or EIE = 1 in the LPUART_CR1 register, or EIE = 1 in the USART_CR3 register. When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set. This bit is permanently forced to 0 (no over run detection) when the bit OVRDIS is set in the USART_CR3 register. NE: Noise detection flag This bit is set by hardware when noise is det ected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register. This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interru pt is generated when the NE flag is set during multi buffer communication if the EIE bit is set. When the line is noise-free, the NE flag c an be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section 48.5.8: Tolerance of the USART receiver to clock deviation on page 2037 ).",
          "values": [
            ["0", "No overrun error"],
            ["1", "Overrun error is detected"],
            ["0", "No noise is detected"],
            ["1", "Noise is detected"]
          ],
          "mask": "0b1000"
        },
        {
          "name": "FE",
          "description": "Framing error This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writi ng 1 to the FECF bit in the USART_ICR register. When transmitting data in Smartcard mode, th is bit is set when the maximum number of transmit attempts is reached without su ccess (the card NACKs the data frame). An interrupt is generated if EIE = 1 in the USART_CR3 register.",
          "values": [
            ["0", "No Framing error is detected"],
            ["1", "Framing error or break character is detected"]
          ],
          "mask": "0b10"
        },
        {
          "name": "PE",
          "description": "Parity error This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register. An interrupt is generated if PEIE = 1 in the USART_CR1 register.",
          "values": [
            ["0", "No parity error"],
            ["1", "Parity error"]
          ],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111101100000000000000000000000"
        }
      ]
    },
    {
      "name": "ICR",
      "description": "interrupt flag clear register",
      "offset": "0x20",
      "fields": [
        {
          "name": "WUCF",
          "description": "Wake-up from low-power mode clear flag Writing 1 to this bit clears the WUF flag in the USART_ISR register. If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b100000000000000000000"
        },
        {
          "name": "CMCF",
          "description": "Character match clear flag Writing 1 to this bit clears the CMF flag in the USART_ISR register.",
          "values": [],
          "mask": "0b100000000000000000"
        },
        {
          "name": "UDRCF",
          "description": "SPI slave underrun clear flag Writing 1 to this bit clears the UDRF flag in the USART_ISR register. If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020",
          "values": [],
          "mask": "0b10000000000000"
        },
        {
          "name": "EOBCF",
          "description": "End of block clear flag Writing 1 to this bit clears the EOBF flag in the USART_ISR register. If the USART does not support Smartcard m ode, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b1000000000000"
        },
        {
          "name": "RTOCF",
          "description": "Receiver timeout clear flag Writing 1 to this bit clears the RTOF flag in the USART_ISR register. If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b100000000000"
        },
        {
          "name": "CTSCF",
          "description": "CTS clear flag Writing 1 to this bit clears the CTSIF flag in the USART_ISR register. If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART impl ementation on page 2020 .",
          "values": [],
          "mask": "0b1000000000"
        },
        {
          "name": "LBDCF",
          "description": "LIN break detection clear flag Writing 1 to this bit clears the LBDF flag in the USART_ISR register. If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 48.4: USART implementation on page 2020 .",
          "values": [],
          "mask": "0b100000000"
        },
        {
          "name": "TCBGTCF",
          "description": "Transmission complete before Guard time clear flag Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.",
          "values": [],
          "mask": "0b10000000"
        },
        {
          "name": "TCCF",
          "description": "Transmission complete clear flag Writing 1 to this bit clears the TC flag in the USART_ISR register.",
          "values": [],
          "mask": "0b1000000"
        },
        {
          "name": "TXFECF",
          "description": "TXFIFO empty clear flag Writing 1 to this bit clears the TXFE flag in the USART_ISR register.",
          "values": [],
          "mask": "0b100000"
        },
        {
          "name": "IDLECF",
          "description": "Idle line detected clear flag Writing 1 to this bit clears the IDLE flag in the USART_ISR register.",
          "values": [],
          "mask": "0b10000"
        },
        {
          "name": "ORECF",
          "description": "Overrun error clear flag Writing 1 to this bit clears the ORE flag in the USART_ISR register.",
          "values": [],
          "mask": "0b1000"
        },
        {
          "name": "NECF",
          "description": "Noise detected clear flag Writing 1 to this bit clears the NE flag in the USART_ISR register.",
          "values": [],
          "mask": "0b100"
        },
        {
          "name": "FECF",
          "description": "Framing error clear flag Writing 1 to this bit clears the FE flag in the USART_ISR register.",
          "values": [],
          "mask": "0b10"
        },
        {
          "name": "PECF",
          "description": "Parity error clear flag Writing 1 to this bit clears the PE flag in the USART_ISR register.",
          "values": [],
          "mask": "0b1"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111011011100010000000000"
        }
      ]
    },
    {
      "name": "RDR",
      "description": "receive data register",
      "offset": "0x24",
      "fields": [
        {
          "name": "RDR",
          "description": "Receive data value Contains the received data character. The RDR register provides the parallel interf ace between the input sh ift register and the internal bus (see Figure 570 ). When receiving with the parity enabled, the val ue read in the MSB bit is the received parity bit.",
          "values": [],
          "mask": "0b111111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111111111111000000000"
        }
      ]
    },
    {
      "name": "TDR",
      "description": "transmit data register",
      "offset": "0x28",
      "fields": [
        {
          "name": "TDR",
          "description": "Transmit data value Contains the data charac ter to be transmitted. The USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 570 ). When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity. This register must be written only when TXE/TXFNF = 1.",
          "values": [],
          "mask": "0b111111111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111111111111000000000"
        }
      ]
    },
    {
      "name": "PRESC",
      "description": "prescaler register",
      "offset": "0x2C",
      "fields": [
        {
          "name": "PRESCALER",
          "description": "Clock prescaler The USART input clock can be divided by a prescaler factor: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.",
          "values": [
            ["0000", "input clock not divided"],
            ["0001", "input clock divided by 2"],
            ["0010", "input clock divided by 4"],
            ["0011", "input clock divided by 6"],
            ["0100", "input clock divided by 8"],
            ["0101", "input clock divided by 10"],
            ["0110", "input clock divided by 12"],
            ["0111", "input clock divided by 16"],
            ["1000", "input clock divided by 32"],
            ["1001", "input clock divided by 64"],
            ["1010", "input clock divided by 128"],
            ["1011", "input clock divided by 256Remaining combinations: Reserved"]
          ],
          "mask": "0b1111"
        },
        {
          "name": "Reserved",
          "description": "must be kept at reset value.",
          "values": [],
          "mask": "0b11111111111111111111111111110000"
        }
      ]
    }
  ]
}
